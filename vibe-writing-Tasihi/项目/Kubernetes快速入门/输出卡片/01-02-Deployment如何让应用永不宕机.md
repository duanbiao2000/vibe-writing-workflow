## Deployment如何让应用永不宕机？

你有没有想过，为什么网上那些大厂的服务能做到99.99%的可用性？难道他们的服务器永远不会坏吗？

当然不是。服务器会坏，网络会断，代码会有bug。真正厉害的是他们的应对机制。

### 从手动管理到声明式管理

在没有Kubernetes的时代，运维是怎么保证服务不中断的？

想象一下这样的场景：
运维人员盯着监控屏幕，发现一台服务器挂了，赶紧手动启动新服务器，配置环境，部署应用...

这种方法有什么问题？
- 人工响应慢（至少几分钟）
- 容易出错（疲劳、疏忽）
- 无法应对大规模部署

Deployment的出现彻底改变了这一切。它引入了"声明式管理"的概念：

```
我想要3个Nginx实例在运行
```

就这么简单一句话，Deployment就会自动确保这个状态一直维持下去。

### 滚动更新：零停机的秘密

传统的应用更新是什么样的？
1. 停掉所有旧实例
2. 启动所有新实例
3. 瞬间服务中断

Deployment的滚动更新则聪明得多：

```
我要把Nginx从1.20升级到1.21
```

Deployment会这样做：
1. 启动一个新版本实例
2. 等它健康检查通过
3. 停掉一个旧版本实例
4. 重复步骤1-3直到全部更新

整个过程用户无感知，这就是所谓的"零停机更新"。

### 回滚：后悔药的艺术

更新后发现新版本有严重bug怎么办？

Deployment保存了每次更新的历史记录（默认10个版本），你可以随时回滚：

```
kubectl rollout undo deployment/nginx-deployment
```

一条命令，瞬间回到上个稳定版本。

更厉害的是，你甚至可以指定回到任意历史版本：
```
kubectl rollout undo deployment/nginx-deployment --to-revision=3
```

### 扩缩容：应对流量洪峰

双11来了，流量暴涨10倍怎么办？

Deployment支持动态扩缩容：
```
kubectl scale deployment/nginx-deployment --replicas=10
```

平时只需要3个实例，高峰期扩展到10个，流量回落后再缩回去。全程自动化，无需人工干预。

### Deployment的核心策略

Deployment有两个关键策略参数：

- `maxUnavailable`：更新过程中允许多少个Pod不可用
- `maxSurge`：更新过程中最多允许超出期望副本数多少个Pod

通过合理配置这两个参数，可以在更新速度和可用性之间找到最佳平衡点。

比如设置：
```yaml
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 1
```

这意味着在更新过程中，始终保持至少(N-1)个Pod运行，最多同时运行(N+1)个Pod，其中N是期望的副本数。

这种精密的控制机制，正是现代云原生应用高可用性的基石。